package org.gusdb.wdk.service.service.user;

import static org.gusdb.wdk.service.service.user.StepService.STEP_ID_PATH_PARAM;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.nio.file.Files;
import java.util.List;
import java.util.Optional;

import javax.ws.rs.Consumes;
import javax.ws.rs.DELETE;
import javax.ws.rs.GET;
import javax.ws.rs.NotFoundException;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.QueryParam;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;

import org.apache.log4j.Logger;
import org.glassfish.jersey.media.multipart.ContentDisposition;
import org.gusdb.fgputil.json.JsonUtil;
import org.gusdb.fgputil.validation.ValidObjectFactory.RunnableObj;
import org.gusdb.fgputil.validation.ValidationLevel;
import org.gusdb.wdk.core.api.JsonKeys;
import org.gusdb.wdk.model.WdkModelException;
import org.gusdb.wdk.model.analysis.StepAnalysis;
import org.gusdb.wdk.model.query.spec.ParameterContainerInstanceSpecBuilder.FillStrategy;
import org.gusdb.wdk.model.query.spec.StepAnalysisFormSpec;
import org.gusdb.wdk.model.user.Step;
import org.gusdb.wdk.model.user.analysis.ExecutionResult;
import org.gusdb.wdk.model.user.analysis.ExecutionStatus;
import org.gusdb.wdk.model.user.analysis.StepAnalysisFactory;
import org.gusdb.wdk.model.user.analysis.StepAnalysisInstance;
import org.gusdb.wdk.service.annotation.PATCH;
import org.gusdb.wdk.service.formatter.StepAnalysisFormatter;
import org.gusdb.wdk.service.request.exception.DataValidationException;
import org.gusdb.wdk.service.request.exception.RequestMisformatException;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

/**
 * Provides endpoints related to step analysis instances.  All endpoints are
 * relative to /users/{id}/steps/{id} (i.e. all pertain to a particular step).
 * They are:
 * 
 * GET    /analyses                      Returns basic info about analysis instances applied on this step (for population of tabs)
 * POST   /analyses                      Create a new analysis instance (input data contains type and param values)
 * GET    /analyses/{id}                 Returns information about an analysis instance (type, display name, status, param values, etc.)
 * PATCH  /analyses/{id}                 Update persisted analysis instance data (display name, param values)
 * DELETE /analyses/{id}                 Deletes an analysis instance
 * POST   /analyses/{id}/result          Kicks off an analysis run if not already running
 * GET    /analyses/{id}/result          Returns analysis run results if available
 * GET    /analyses/{id}/result/status   Returns analysis run status
 * GET    /analyses/{id}/resources?path  Returns a file resource generated by this analysis instance
 * GET    /analyses/{id}/properties      Returns arbitrary properties attached to this analysis instance
 * PUT    /analyses/{id}/properties      Sets arbitrary properties attached to this analysis instance
 * 
 * See also: StepAnalysisFormService
 * 
 * @author eharper
 */
public class StepAnalysisInstanceService extends AbstractUserService implements StepAnalysisLookupMixin {

  private static final Logger LOG = Logger.getLogger(StepAnalysisInstanceService.class);

  // endpoints to handle analysis instances for a given step
  private static final String ANALYSES_PATH = StepService.NAMED_STEP_PATH + "/analyses";
  private static final String ANALYSIS_ID_PATH_PARAM = "analysisId";
  private static final String NAMED_ANALYSIS_PATH = ANALYSES_PATH + "/{" + ANALYSIS_ID_PATH_PARAM + "}";

  // sub-endpoints for an analysis instance
  private static final String NAMED_ANALYSIS_RESULT_PATH = NAMED_ANALYSIS_PATH + "/result";
  private static final String NAMED_ANALYSIS_RESULT_STATUS_PATH = NAMED_ANALYSIS_RESULT_PATH + "/status";
  private static final String NAMED_ANALYSIS_RESOURCES_PATH = NAMED_ANALYSIS_PATH + "/resources";
  private static final String NAMED_ANALYSIS_PROPERTIES_PATH = NAMED_ANALYSIS_PATH + "/properties";

  private static final String RESOURCE_PATH_QUERY_PARAM = "path";
  private static final String ACCESS_TOKEN_QUERY_PARAM = "accessToken";

  private static final String CONTEXT_HASH_KEY = "contextHash";
  private static final String ACCESS_TOKEN_KEY = "accessToken";
  private static final String DOWNLOAD_URL_KEY = "downloadUrl";
  private static final String PROPERTIES_URL_KEY = "propertiesUrl";

  private final long _stepId;

  protected StepAnalysisInstanceService(
      @PathParam(USER_ID_PATH_PARAM) String uid,
      @PathParam(STEP_ID_PATH_PARAM) long stepId) {
    super(uid);
    _stepId = stepId;
  }

  @Override
  public long getStepId() {
    return _stepId;
  }

  /**
   * Create a new step analysis; expects JSON in the following format:
   * {
   *   analysisName: string
   *   parameters:   object&gt;string,string>
   *   displayName?: string
   * }
   * @param json input JSON string
   * @return Details of the newly created step analysis instance as JSON
   */
  @POST
  @Path(ANALYSES_PATH)
  @Consumes(MediaType.APPLICATION_JSON)
  @Produces(MediaType.APPLICATION_JSON)
  public JSONObject createStepAnalysis(JSONObject json)
      throws RequestMisformatException, DataValidationException, WdkModelException {
    try {
      // make sure step is runnable
      RunnableObj<Step> step = getRunnableStepForCurrentUser(_stepId);

      // validate analysis name and look up plugin
      StepAnalysis stepAnalysis = getStepAnalysisFromQuestion(
          step.get().getAnswerSpec().getQuestion().get(),
          json.getString(JsonKeys.ANALYSIS_NAME));

      // validate form params
      RunnableObj<StepAnalysisFormSpec> formSpec = StepAnalysisFormSpec.builder()
          .putAll(JsonUtil.parseProperties(json.getJSONObject(JsonKeys.PARAMETERS)))
          .buildValidated(step, stepAnalysis, ValidationLevel.RUNNABLE, FillStrategy.NO_FILL)
          .getRunnable().getOrThrow(spec -> new DataValidationException(spec.getValidationBundle()));

      // create instance if params are valid; else throw
      RunnableObj<StepAnalysisInstance> instance = StepAnalysisInstance
          .createUnsavedInstance(step, stepAnalysis, formSpec)
          .getRunnable().getOrThrow(inst -> new DataValidationException(inst.getValidationBundle()));

      // add custom display name if specified
      getValidDisplayName(json).ifPresent(validName -> instance.get().setDisplayName(validName));

      // save instance to database
      getWdkModel().getStepAnalysisFactory().saveNewInstance(instance);

      // format new instance to JSON and return
      return StepAnalysisFormatter.getStepAnalysisInstanceJson(instance.get(), ExecutionStatus.CREATED);
    }
    catch (JSONException e) {
      throw new RequestMisformatException(e.getMessage());
    }
  }

  private static Optional<String> getValidDisplayName(JSONObject json) throws DataValidationException {
    if (!json.has(JsonKeys.DISPLAY_NAME)) return Optional.empty();
    String newDisplayName = json.getString(JsonKeys.DISPLAY_NAME).trim();
    if (newDisplayName.isEmpty()) {
      throw new DataValidationException("Display name field cannot be empty.");
    }
    return Optional.of(newDisplayName);
  }

  /**
   * List of applied step analysis instances
   *
   * @return JSON response containing an array of basic analysis instance details
   * @throws DataValidationException
   */
  @GET
  @Path(ANALYSES_PATH)
  @Produces(MediaType.APPLICATION_JSON)
  public JSONArray getStepAnalysisInstanceList() throws WdkModelException, DataValidationException {
    getUserBundle(Access.PRIVATE); // make sure session user matches target user
    List<StepAnalysisInstance> analyses = getWdkModel()
        .getStepAnalysisFactory()
        .getAppliedAnalyses(getRunnableStepForCurrentUser(_stepId).get(), ValidationLevel.NONE);
    return StepAnalysisFormatter.getStepAnalysisInstancesJson(analyses);
  }

  @GET
  @Path(NAMED_ANALYSIS_PATH)
  @Produces(MediaType.APPLICATION_JSON)
  public JSONObject getStepAnalysisInstance(
      @PathParam(ANALYSIS_ID_PATH_PARAM) long analysisId,
      @QueryParam(ACCESS_TOKEN_QUERY_PARAM) String accessToken) throws WdkModelException, DataValidationException {

    StepAnalysisFactory factory = getWdkModel().getStepAnalysisFactory();

    // make sure the chosen analysis is still compatible with this step
    RunnableObj<Step> step = getRunnableStepForCurrentUser(_stepId);

    // validate this analysis is still valid for the results of this step (no validation in case not valid for step)
    StepAnalysisInstance checkStepInstance = getAnalysis(analysisId, accessToken, ValidationLevel.NONE);
    StepAnalysis stepAnalysis = getStepAnalysisFromQuestion(step.get().getAnswerSpec().getQuestion().get(), checkStepInstance.getAnalysisName());
    validStepForAnalysisOrThrow(step, stepAnalysis);

    // get execution status of this instance; need runnably validated (but not necessarily valid) instance
    StepAnalysisInstance checkStatusInstance = getAnalysis(analysisId, accessToken, ValidationLevel.RUNNABLE);
    ExecutionStatus status = factory.calculateStatus(checkStatusInstance);

    // create a displayable instance for population of the form
    StepAnalysisInstance returnInstance = getAnalysis(analysisId, accessToken, ValidationLevel.DISPLAYABLE);
    return StepAnalysisFormatter.getStepAnalysisInstanceJson(returnInstance, status);
  }

  // TODO: Why is this so slow?
  @DELETE
  @Path(NAMED_ANALYSIS_PATH)
  public void deleteStepAnalysisInstance(
      @PathParam(ANALYSIS_ID_PATH_PARAM) long analysisId,
      @QueryParam(ACCESS_TOKEN_QUERY_PARAM) String accessToken) throws WdkModelException {
    getWdkModel().getStepAnalysisFactory().deleteAnalysis(getAnalysis(analysisId, accessToken, ValidationLevel.NONE));
  }

  @PATCH
  @Path(NAMED_ANALYSIS_PATH)
  @Consumes(MediaType.APPLICATION_JSON)
  public void updateStepAnalysisInstance(
      @PathParam(ANALYSIS_ID_PATH_PARAM) long analysisId,
      @QueryParam(ACCESS_TOKEN_QUERY_PARAM) String accessToken,
      JSONObject json) throws WdkModelException, DataValidationException {

    // make sure step is runnable (user should not be able to see form if step not runnable)
    RunnableObj<Step> step = getRunnableStepForCurrentUser(_stepId);

    // look up instance and confirm plugin still supported
    StepAnalysisInstance instance = getAnalysis(analysisId, accessToken, ValidationLevel.SYNTACTIC);
    StepAnalysis plugin = instance.getStepAnalysis().orElseThrow(() ->
        new DataValidationException("This analysis refers to a plugin '" +
            instance.getAnalysisName() + "' that is no longer supported."));

    // check for params field and validate new values before assigning
    if (json.has(JsonKeys.PARAMETERS)) {
      // validate form params
      RunnableObj<StepAnalysisFormSpec> formSpec = StepAnalysisFormSpec.builder()
        .putAll(JsonUtil.parseProperties(json.getJSONObject(JsonKeys.PARAMETERS)))
        .buildValidated(step, plugin, ValidationLevel.RUNNABLE, FillStrategy.NO_FILL)
        .getRunnable().getOrThrow(spec -> new DataValidationException(spec.getValidationBundle()));
      // valid; set on instance
      instance.setFormParams(formSpec, ValidationLevel.SYNTACTIC);
    }

    // apply display name modification if present and valid
    getValidDisplayName(json).ifPresent(validName -> instance.setDisplayName(validName));

    // apply user notes modification
    if (json.has(JsonKeys.USER_NOTES)) {
      instance.setUserNotes(json.getString(JsonKeys.USER_NOTES));
    }

    // save changes to database
    getWdkModel().getStepAnalysisFactory().updateInstance(instance);
  }

  @GET
  @Path(NAMED_ANALYSIS_RESULT_PATH)
  @Produces(MediaType.APPLICATION_JSON)
  public Response getStepAnalysisResult(
    @PathParam(ANALYSIS_ID_PATH_PARAM) long analysisId,
    @QueryParam(ACCESS_TOKEN_QUERY_PARAM) String accessToken
  ) throws WdkModelException, DataValidationException, JSONException {

    StepAnalysisFactory factory = getWdkModel().getStepAnalysisFactory();

    RunnableObj<StepAnalysisInstance> instance = getAnalysis(analysisId, accessToken, ValidationLevel.RUNNABLE)
        .getRunnable().getOrThrow(inst -> new DataValidationException(
            "This analysis instance is not currently runnable and cannot return results."));

    Optional<ExecutionResult> result = factory.getExecutionResult(instance);
    if (result.isEmpty()) {
      return Response.noContent().build();
    }

    String analysisUrl = getAnalysisUrl(instance.get());
    JSONObject resultJson = result.get().getResultJson()
      .put(CONTEXT_HASH_KEY, StepAnalysisInstance.getContextHash(instance))
      .put(ACCESS_TOKEN_KEY, instance.get().getAccessToken())
      .put(DOWNLOAD_URL_KEY, analysisUrl + "/resources")
      .put(PROPERTIES_URL_KEY, analysisUrl + "/properties");

    return Response.ok(resultJson.toString()).build();
  }

  private String getAnalysisUrl(StepAnalysisInstance instance) {
    return String.format("%s/users/%d/steps/%d/analyses/%d",
        getServiceUri(), instance.getStep().getOwningUser().getUserId(),
        instance.getStep().getStepId(), instance.getAnalysisId());
  }

  @POST
  @Path(NAMED_ANALYSIS_RESULT_PATH)
  @Produces(MediaType.APPLICATION_JSON)
  public Response runAnalysis(
    @PathParam(ANALYSIS_ID_PATH_PARAM) long analysisId,
    @QueryParam(ACCESS_TOKEN_QUERY_PARAM) String accessToken
  ) throws WdkModelException, DataValidationException {

    RunnableObj<StepAnalysisInstance> instance = getAnalysis(analysisId, accessToken, ValidationLevel.RUNNABLE)
      .getRunnable().getOrThrow(inst -> new DataValidationException(inst.getValidationBundle()));

    ExecutionStatus status = getWdkModel().getStepAnalysisFactory().runAnalysis(instance);

    return Response.accepted()
        .entity(new JSONObject().put(JsonKeys.STATUS, status.name()))
        .build();
  }

  @GET
  @Path(NAMED_ANALYSIS_RESULT_STATUS_PATH)
  @Produces(MediaType.APPLICATION_JSON)
  public JSONObject getStepAnalysisResultStatus(
    @PathParam(ANALYSIS_ID_PATH_PARAM) long analysisId,
    @QueryParam(ACCESS_TOKEN_QUERY_PARAM) String accessToken
  ) throws WdkModelException, DataValidationException {
    RunnableObj<StepAnalysisInstance> instance = getAnalysis(analysisId, accessToken, ValidationLevel.RUNNABLE)
        .getRunnable().getOrThrow(inst -> new DataValidationException(inst.getValidationBundle()));
    return new JSONObject().put(JsonKeys.STATUS,
        getWdkModel().getStepAnalysisFactory().calculateStatus(instance.get()));
  }

  @GET
  @Path(NAMED_ANALYSIS_RESOURCES_PATH)
  public Response getStepAnalysisResource(
    @PathParam(ANALYSIS_ID_PATH_PARAM) long analysisId,
    @QueryParam(RESOURCE_PATH_QUERY_PARAM) String path,
    @QueryParam(ACCESS_TOKEN_QUERY_PARAM) String accessToken
  ) throws Exception {
    StepAnalysisFactory stepAnalysisFactory = getWdkModel().getStepAnalysisFactory();
    RunnableObj<StepAnalysisInstance> instance = getAnalysis(analysisId, accessToken, ValidationLevel.RUNNABLE)
        .getRunnable().getOrThrow(inst -> new DataValidationException(inst.getValidationBundle()));
    java.nio.file.Path resourcePath = stepAnalysisFactory.getResourcePath(
      instance,
      path
    );

    File resourceFile = resourcePath.toFile();
    if (resourceFile.exists() && resourceFile.isFile() && resourceFile.canRead()) {
      InputStream resourceStream = new BufferedInputStream(new FileInputStream(resourceFile));
      String contentType = Files.probeContentType(resourcePath);
      LOG.info("Streaming file " + resourcePath + " with content type " + contentType);
      return Response.ok(getStreamingOutput(resourceStream))
        .type(contentType)
        .header(
          "Content-Disposition",
          ContentDisposition.type("attachment").fileName(
            resourceFile.getName()
          ).build()
        )
        .build();
    }

    throw new NotFoundException("Could not find resource " + path + " for step analysis " + analysisId);
  }

  @GET
  @Path(NAMED_ANALYSIS_PROPERTIES_PATH)
  @Produces(MediaType.TEXT_PLAIN)
  public Response getStepAnalysisProperties(
    @PathParam(ANALYSIS_ID_PATH_PARAM) long analysisId,
    @QueryParam(ACCESS_TOKEN_QUERY_PARAM) String accessToken
  ) throws WdkModelException {
    StepAnalysisInstance instance = getAnalysis(analysisId, accessToken, ValidationLevel.NONE);
    InputStream propertiesStream = getWdkModel().getStepAnalysisFactory().getProperties(instance);
    return Response.ok(getStreamingOutput(propertiesStream)).build();
  }

  @PUT
  @Path(NAMED_ANALYSIS_PROPERTIES_PATH)
  @Consumes(MediaType.TEXT_PLAIN)
  public void setStepAnalysisProperties(
      @PathParam(ANALYSIS_ID_PATH_PARAM) long analysisId,
      @QueryParam(ACCESS_TOKEN_QUERY_PARAM) String accessToken,
      InputStream body) throws WdkModelException {
    StepAnalysisInstance instance = getAnalysis(analysisId, accessToken, ValidationLevel.NONE);
    getWdkModel().getStepAnalysisFactory().setProperties(instance, body);
  }
}
